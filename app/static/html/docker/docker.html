<!doctype html>
<html lang="en">
<head>
    <meta charset="UTF-8"/>
    <meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1"/>
    <meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1"/>
    <meta http-equiv="Cache-Control" content="no-transform"/>
    <meta http-equiv="Cache-Control" content="no-siteapp"/>
    <link href="/static/vendors/fancybox/source/jquery.fancybox.css" rel="stylesheet" type="text/css"/>
    <link href="//fonts.googleapis.com/css?family=Lato:300,300italic,400,400italic,700,700italic&subset=latin,latin-ext"
          rel="stylesheet" type="text/css">
    <link href="/static/vendors/font-awesome/css/font-awesome.min.css" rel="stylesheet" type="text/css"/>
    <link href="/static/css/main.css" rel="stylesheet" type="text/css"/>

    <meta name="keywords" content="Hexo, NexT"/>
    <link rel="shortcut icon" type="image/x-icon" href="/favicon.ico"/>

    <meta property="og:type" content="website">
    <meta property="og:title" content="Crow的技术博客">
    <meta property="og:url" content="http://southpeak.github.io/categories/objectivec/index.html">
    <meta property="og:site_name" content="Crow的技术博客">
    <meta name="twitter:card" content="summary">
    <meta name="twitter:title" content="Crow的技术博客">

    <script type="text/javascript" id="hexo.configuration">
        var NexT = window.NexT || {};
        var CONFIG = {
            scheme: 'Pisces',
            sidebar: {"position": "left", "display": "post"},
            fancybox: true,
            motion: true,
            duoshuo: {
                userId: 0,
                author: '博主'
            }
        };
    </script>

    <link rel="canonical" href="47.106.99.78:8080/docker"/>
    <title>Docker 常用命令 | Crow的技术博客</title>
    <!--设置图标-->
    <!--<link rel="shortcut icon" href="image/abc.jpg">-->

    <h1 style="left: 2%">Docker 常用命令备忘</h1>
</head>

<body lang="zh-Hans">

<script>
    (function (i, s, o, g, r, a, m) {
        i['GoogleAnalyticsObject'] = r;
        i[r] = i[r] || function () {
            (i[r].q = i[r].q || []).push(arguments)
        }, i[r].l = 1 * new Date();
        a = s.createElement(o),
            m = s.getElementsByTagName(o)[0];
        a.async = 1;
        a.src = g;
        m.parentNode.insertBefore(a, m)
    })(window, document, 'script', '//www.google-analytics.com/analytics.js', 'ga');
    ga('create', 'UA-68856508-1', 'auto');
    ga('send', 'pageview');
</script>

<div>
    <div class="title">基本语法:</div>
    <div class="content">`
        docker run [OPTIONS] IMAGE [COMMAND] [ARG...]
    </div>
</div>

<div style="color:#000000">
    <h3 style="color: #FFFFFF"> 常用命令</h3>
    <div>
        <h4 style="color: #FFFFFF">容器相关:</h4>
        <p class="command"> docker ps&nbsp&nbsp&nbsp&nbsp</p>
        <p> 查看正在运行的容器。</p>
        <p class="command"> docker ps -a&nbsp&nbsp&nbsp&nbsp</p>
        <p> 查看本地全部容器。</p>
        <p class="command"> docker -e &nbsp&nbsp&nbsp&nbsp
        <p>在实际应用场景中，不论是从安全还是可配置方面去考虑，很多参数是比较适合用环境变量加载进去的，比如数据库的连接信息，时区，还有字体支持等等，在创建容器的时候其实都可以使用-e
            指定key/value进行传递环境变量进去。 </p>
        <p class="command"> docker port id&nbsp&nbsp&nbsp&nbsp
        <p>可以查看指定 容器的某个确定端口映射到宿主机的端口号。</p>
        <p class="command"> docker logs id&nbsp&nbsp&nbsp&nbsp
        <p> 可以查看容器日志</p>
        <p class="command"> docker inspect &nbsp&nbsp&nbsp&nbsp
        <p>查看Docker的底层信息。它会返回一个 JSON 文件记录着 Docker 容器的配置和状态信息</p>
        <p class="command"> docker create 'name'&nbsp&nbsp&nbsp&nbsp
        <p style="width:85%"> 创建容器</p>
        <p class="command"> docker start 'name'&nbsp&nbsp&nbsp&nbsp
        <p style="width: 85%"> 启动容器</p>
        <p class="command"> docker run 'name'&nbsp&nbsp&nbsp&nbsp
        <p> 创建并启动容器，run 命令包含了create和start俩个命令</p>
        <p class="command"> docker rm id &nbsp&nbsp&nbsp&nbsp
        <p>移除不需要的容器 ,需先停止容器</p>
        <p class="command"> docker exec -it "id" /bin/bash &nbsp&nbsp&nbsp&nbsp
        <p style="width: 80%"> 进入容器</p>
        <p class="command"> Ctrl+P+Q&nbsp&nbsp&nbsp&nbsp
        <p>退出容器,容器会继续运行</p>
        <p class="command"> exit 容器内使用&nbsp&nbsp&nbsp&nbsp
        <p>退出并且关闭容器</p>
        <p class="command"> docker -d &nbsp&nbsp&nbsp&nbsp
        <p> 容器后台运行，
            Dockerfile中CMD会直接关闭docker。但是-d并不意味着脚本永远执行，而是可以后台运行，也就是说我们需要开一个前台的程序让脚本挂起。如果脚本执行结束，那么容器也就关闭了。可以直接使用-it连用，会在容器中打开一个输入终端。这样就实现了挂起前台的任务。</p>
    </div>
    <div>
        <h4 style="color: #FFFFFF;float:left;width: 100%">镜像相关:</h4>
        <p class="command"> docker images&nbsp&nbsp&nbsp&nbsp
        <p> 查看镜像</p>
        <p class="command"> docker save -o image_name.tar image_name&nbsp&nbsp&nbsp&nbsp
        <p class="langConnect"> 导出镜像</p>
        <p class="command"> docker rmi &nbsp&nbsp&nbsp&nbsp
        <p>删除镜像，需先rm容器</p>
        <p class="command"> commit &nbsp&nbsp&nbsp&nbsp
        <p>创建新镜像</p>
        <p class="command"> docker search [name]&nbsp&nbsp&nbsp&nbsp
        <p style="width: 70%"> 查找镜像</p>
        <p> docker image 和 container 区别。image文件是只读的，container可以读写。container在image基础上修改。<a style="color: green"
                                                                                          href="https://www.cnblogs.com/bethal/p/5942369.html"
                                                                                          target="_blank"
                                                                                          title="container和image区别详解">container和image区别详解</a>
        </p>

    </div>

    <div>
        <h4 style="color: #FFFFFF;float:left;width: 100%">运行命令解释:</h4>
        <p class="command"> docker run -ditp 8080:8080 -v /root/software/:/software/flask -w /software/flask --name=XXX
            docker.io/python /bin/bash&nbsp&nbsp&nbsp&nbsp
        <p class="langConnect">本项目构建使用docker启动命令 -d 保持后台运行 -it创建完成后进入这个容器并打开容器内控制台 -w /software/flask
            :指定容器的/software/flask目录为工作目录，不存在会创建。-v /code:/usr/src/app
            表示把宿主机上的/code目录挂载到容器内的/usr/src/app目录，可以通过直接管理宿主机上的挂载目录来管理容器内部的挂载目录。:为分割之前为宿主机路径。</p>
    </div>


</div>

</body>
</html>

